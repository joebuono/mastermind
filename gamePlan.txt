Next Steps:

2/18/21

- Drag and Drop
- Dynamically resize boards, circles, and all components

CLEAN UP CODE
- Comb through all the code and make the variable, module, and css style names consistent
  - Rounds, Turns, ATTEMPTS, Guesses, BWPegs, human or player, computer/ai/algorithm

- React Tooltips
- Show Global Knowledge at top of Board component (on player turn)?

- Expand Console to show options
- Console in the middle can expand to show additional Options:
  - Hide/show ColorTracker
  - Restart
  - Home

- Explore react-spring for animations

- Media queries (mobile responsive)









2/16/21
- Console in the middle

2/15/21

Other
- CSS animations
- Consider exploring Redux


- During player mode, click on suggested next guess element to reveal it, and also give an additional point to the computer
- What happens when all 3 rounds have been played? Play again?
- Implement different modes: learning mode

After that, it's all UI, UX
- Make it look incredible, beautiful colors
- Smooth animations too, enhancing it
- Click and drag color to guess is important
- React Tooltips to explain the columns, etc

Only re-render the color tracker when a guess is submitted

2/11/21
- Factor out getNextComputerGuess logic into its own folder (frontendLogic)
- Display ColorTracker data and suggested best next guess for player
- Possibly: Consolidate player and computer boards
- Make ColorTracker a child component of Board
- Make all the functions modular (no bloated functions!)

- Investigate click and drag functionality
- Make currentTurn, currentRound terminology consistent

- I think I know what the bug is with the solver algorithm. 
  After the first guess, we want to select the valid permutations that contains only the color which MATCHES the color we know the least about

- At the end of three rounds, display some kind of message saying that you're a fullstack software engineer looking for a job. 
  - And link to your GitHub for the project, as well as LinkedIn!
  - And your lecture on the solver algorithm!

Specific:
- Double-click to remove color from guess (later, drag off the board)
- When you click on a color option, it will animate it's motion to the next available position in the guess
- Make current turn a slightly different background color on the board (lighter?)

Game flow bug:
- Make sure you can handle the points when either the player or computer loses a round (add a bonus as well)

Stylistic stuff:
- Work on draggable and swappable colors
- Animate the computer's guesses
- Make the ColorTracker look pretty
- In the ColorTracker, display possible permutations (in a pop-up full screen modal)
- In the ColorTracker, display (suggested) bestNextGuess for both player and computer
- Explore Rodal.js for the MakeCode component (helps with making modals)

Algorithmic stuff
- See photos in your iPhone documenting algorithmic bugs
- Say the code is 'rrrb' and the computer guess 'gggy'. It says that there are EITHER 0 OR 5 possible positions
  for the other colors. This is incorrect. There are 0 THROUGH 5 possible positions for every other color than r and b. Fix this. 
- Explore making graded difficulties for the computer
- Once the computer knows the location of one peg for sure, shift to playing 4-code game (see photos in iPhone for bug)
- Perhaps the computer doesn't need to split the first guess into 3 and 1 or 2. For example, instead of guessing
  'rrrbb', it could guess 'rbrrb', or something like that. I just split it the same way because it's visually easier
  for my human brain to keep track of where the colors need to go. But this adjustment might prove to be an optimization
  BUT... this wouldn't be as good for teaching people how to play the game

Game Plan

We need to use uniform variable names across the frontend and backend

There is a Board, which consists of a SecretCode, a container of Turns (8, 10 or 12), and a set of ColorOptions
- Each Turn consists of a Guess and BWPegs (the feedback for the guess)

The primary data structure is the ColorTracker

The ColorTracker is a table that consists of Headers and Rows
- The Headers include Color, Number, and Position
- Each Row consists of a color, number, and position data for each available color option
- Furthermore, position data is displayed similar to each guess, but using check marks, red x's, and question marks to indicate the current knowledge for position

In the View, you can toggle on/off the ColorTracker

Perhaps embed a tutoral video of you explaining the rules of the game, and perhaps some basic strategy
- Make another video that takes a deep dive into the algorithm

____________________________

Game Play

A game is a sequence of a set number of X rounds in which the player and the computer alternate roles as the code-maker and code-breaker

Game -> Round -> Role -> Turn -> Guess

The code-maker get a point for each guess the code-breaker makes, and a bonus if the code-breaker doesn't correctly guess the code within the specified number of turns

The winner has the most points after X rounds

Difficulty is calculated based on two parameters: code size (4 or 5) and number of guesses per turn (8, 10 or 12)
From easiest to most difficult, progressively:
- Size: 4, Turns: 12
- Size: 4, Turns: 10
- Size: 4, Turns: 8
- Size: 5, Turns: 12
- Size: 5, Turns: 10
- Size: 5, Turns: 8

These are somewhat arbitrary since the algorithm is still the same, regardless of the number of rounds

Think of funny, cool names for these difficulty levels. 
- Perhaps change the avatar for each level! (e.g., starts with a baby penguin, and ends with Yoda)

____________________________

Actionable Steps (Trello)

* Finish implementing code-breaker mode
- Decide how you want to start data for Turns (I'm thinking an array of objects, each index representing the turn - 1)
  - We may have to adjust the solver algorithm to use this same data structure (I think it's an object of objects right now)
- Get the View to display each Turn as a Guess component and a BWPegs component
  - You'll need to rewrite your display logic
- Get the ColorTracker to update in the View after each Turn

* Implement code-maker mode
- Make a copy of the board component for now. Later, we'll figure out if it is possible to use the same Board component, but use it differently depending on whether
  the player is the code-maker or code-breaker. 
- Connect the solver-algorithm logic to the View
- Make a button that tells the computer to make the next move. 

* Implement Game-level logic
- Figure out how and where to keep track of Rounds, Roles, and Scores for the player and computer

* Test
- Get your friends to try it out and offer feedback

* Polish, polish, polish
- Dynamic board sizing, depending on code size and number of turns, as well as screen size
- All CSS, animations, styling, etc
- Figure out how to let the user click and drag color to their spots, and also delete by double-clicking or dragging off the board

* Record videos for tutorial and algorithm walk-through
- Remember, you're aiming to get a job. 

* Nightmare Mode

- jQuery has a draggable plugin, there should be something equivalent for React

- Deploy on Vercel (ask Ethan, he said the docs are good)

- Write blog post for Hacker News

- GraphQL?
- Implement a simple backend for storing user info and score data
- Use D3 to display user statistics, progress bars, achievement badges, ranking among all users
- Implement OAuth for authentication
- Explore the possibility of using Next.js
- Implement live two-player mode with Socket.io
- Explore CircleCI for automated testing
- Use media queries to format it for phones and screens of all sizes
- Optimize the algorithm based on Donald Knuth's work
- Implement practice mode, where you can practice without it affecting your score or ranking
- Implement graded difficulties, based on how rigorous the filtering/selection is for the best next guess
- Docker

* Deployment
- You have some options

