Next Steps:

Specific:
- Double-click to remove color from guess (later, drag off the board)
- When you click on a color option, it will automatically populate the next guess with that color
- Make current turn a slightly different background color on the board (lighter?)
- Make black, white, and empty pegs for the BWPegs

Stylistic stuff:
- Work on draggable and swappable colors
- Animate the computer's guesses
- Make the ColorTracker look pretty
- In the ColorTracker, display possible permutations
- In the ColorTracker, display (suggested) bestNextGuess for both player and computer
- Explore Rodal.js for the MakeCode component (helps with making modals)

Algorithmic stuff
- Say the code is 'rrrb' and the computer guess 'gggy'. It says that there are EITHER 0 OR 5 possible positions
  for the other colors. This is incorrect. There are 0 THROUGH 5 possible positions for every other color than r and b. Fix this. 
- Explore making graded difficulties for the computer
- Once the computer knows the location of one peg for sure, shift to playing 4-code game (see photos in iPhone for bug)

Game Plan

We need to use uniform variable names across the frontend and backend

There is a Board, which consists of a SecretCode, a container of Turns (8, 10 or 12), and a set of ColorOptions
- Each Turn consists of a Guess and BWPegs (the feedback for the guess)

The primary data structure is the ColorTracker

The ColorTracker is a table that consists of Headers and Rows
- The Headers include Color, Number, and Position
- Each Row consists of a color, number, and position data for each available color option
- Furthermore, position data is displayed similar to each guess, but using check marks, red x's, and question marks to indicate the current knowledge for position

In the View, you can toggle on/off the ColorTracker

Perhaps embed a tutoral video of you explaining the rules of the game, and perhaps some basic strategy
- Make another video that takes a deep dive into the algorithm

____________________________

Game Play

A game is a sequence of a set number of X rounds in which the player and the computer alternate roles as the code-maker and code-breaker

Game -> Round -> Role -> Turn -> Guess

The code-maker get a point for each guess the code-breaker makes, and a bonus if the code-breaker doesn't correctly guess the code within the specified number of turns

The winner has the most points after X rounds

Difficulty is calculated based on two parameters: code size (4 or 5) and number of guesses per turn (8, 10 or 12)
From easiest to most difficult, progressively:
- Size: 4, Turns: 12
- Size: 4, Turns: 10
- Size: 4, Turns: 8
- Size: 5, Turns: 12
- Size: 5, Turns: 10
- Size: 5, Turns: 8

These are somewhat arbitrary since the algorithm is still the same, regardless of the number of rounds

Think of funny, cool names for these difficulty levels. 
- Perhaps change the avatar for each level! (e.g., starts with a baby penguin, and ends with Yoda)

____________________________

Actionable Steps (Trello)

* Finish implementing code-breaker mode
- Decide how you want to start data for Turns (I'm thinking an array of objects, each index representing the turn - 1)
  - We may have to adjust the solver algorithm to use this same data structure (I think it's an object of objects right now)
- Get the View to display each Turn as a Guess component and a BWPegs component
  - You'll need to rewrite your display logic
- Get the ColorTracker to update in the View after each Turn

* Implement code-maker mode
- Make a copy of the board component for now. Later, we'll figure out if it is possible to use the same Board component, but use it differently depending on whether
  the player is the code-maker or code-breaker. 
- Connect the solver-algorithm logic to the View
- Make a button that tells the computer to make the next move. 

* Implement Game-level logic
- Figure out how and where to keep track of Rounds, Roles, and Scores for the player and computer

* Test
- Get your friends to try it out and offer feedback

* Polish, polish, polish
- Dynamic board sizing, depending on code size and number of turns, as well as screen size
- All CSS, animations, styling, etc
- Figure out how to let the user click and drag color to their spots, and also delete by double-clicking or dragging off the board

* Record videos for tutorial and algorithm walk-through
- Remember, you're aiming to get a job. 

* Nightmare Mode

- jQuery has a draggable plugin, there should be something equivalent for React

- Deploy on Vercel (ask Ethan, he said the docs are good)

- Write blog post for Hacker News

- Implement a simple backend for storing user info and score data
- Use D3 to display user statistics, progress bars, achievement badges, ranking among all users
- Implement OAuth for authentication
- Explore the possibility of using Next.js
- Implement live two-player mode with Socket.io
- Explore CircleCI for automated testing
- Use media queries to format it for phones and screens of all sizes
- Optimize the algorithm based on Donald Knuth's work
- Implement practice mode, where you can practice without it affecting your score or ranking
- Implement graded difficulties, based on how rigorous the filtering/selection is for the best next guess
- Docker

* Deployment
- You have some options

